package main

import (
	"log"
	"strings"
	"text/template"
	"unicode"

	pgs "github.com/lyft/protoc-gen-star"
	pgsgo "github.com/lyft/protoc-gen-star/lang/go"
)

var (
	genRPCStubLabel = "@@nprpc@@"
	genMsgStubLabel = "@@npmsg@@"
)

// nprotoModule is a module of protoc-gen-star.
type nprotoModule struct {
	pgs.ModuleBase
	ctx         pgsgo.Context
	skeletonTpl *template.Template
	importsTpl  *template.Template
	nprpcTpl    *template.Template
	npmsgTpl    *template.Template
}

// InitContext implements pgs.Module interface.
func (m *nprotoModule) InitContext(c pgs.BuildContext) {
	m.ModuleBase.InitContext(c)
	m.ctx = pgsgo.InitContext(c.Parameters())

	funcs := map[string]interface{}{
		"Name": func(node pgs.Node) pgs.Name {
			switch n := node.(type) {
			case pgs.Service:
				// NOTE: We don't need the "Server" suffix.
				return pgsgo.PGGUpperCamelCase(n.Name())
			default:
				return m.ctx.Name(node)
			}
		},
		"PackageName": m.ctx.PackageName,
		"ImportPath":  m.ctx.ImportPath,
		"LeadingComments": func(entity pgs.Entity) string {
			comments := strings.TrimRightFunc(entity.SourceCodeInfo().LeadingComments(), unicode.IsSpace)
			if comments == "" {
				return ""
			}
			lines := strings.Split(comments, "\n")
			for i, line := range lines {
				lines[i] = "//" + line
			}
			return strings.Join(lines, "\n")
		},
	}
	newTpl := func(name, text string) *template.Template {
		return template.Must(template.New(name).Funcs(funcs).Parse(text))
	}
	m.skeletonTpl = newTpl("skeleton", skeletonTplText)
	m.importsTpl = newTpl("imports", importsTplText)
	m.nprpcTpl = newTpl("nprpc", nprpcTplText)
	m.npmsgTpl = newTpl("npmsg", npmsgTplText)
}

// Name implements pgs.Module interface.
func (m *nprotoModule) Name() string {
	return "nproto"
}

// Execute implements pgs.Module interface.
func (m *nprotoModule) Execute(targets map[string]pgs.File, packages map[string]pgs.Package) []pgs.Artifact {
	// For each target file.
	for _, target := range targets {
		// Replace ".pb.go" to "nproto.go"
		targetName := strings.TrimSuffix(string(m.ctx.OutputPath(target)), ".pb.go") + ".nproto.go"

		// Create file context for target.
		fctx := newFileContext(m, target)

		// Create target file with skeleton.
		m.AddGeneratorTemplateFile(targetName, m.skeletonTpl, map[string]interface{}{
			"File":        target,
			"FileContext": fctx,
		})

		// Insert nprpc code.
		for _, service := range target.Services() {
			if !strings.Contains(service.SourceCodeInfo().LeadingComments(), genRPCStubLabel) {
				continue
			}
			for _, method := range service.Methods() {
				if method.ClientStreaming() || method.ServerStreaming() {
					log.Fatal("nproto.nprpc does not support streaming input/output")
				}
			}
			m.AddGeneratorTemplateInjection(targetName, "nprpc", m.nprpcTpl, map[string]interface{}{
				"Service":     service,
				"FileContext": fctx,
			})
		}

		// Insert npmsg code.
		for _, message := range target.Messages() {
			if !strings.Contains(message.SourceCodeInfo().LeadingComments(), genMsgStubLabel) {
				continue
			}
			m.AddGeneratorTemplateInjection(targetName, "npmsg", m.npmsgTpl, map[string]interface{}{
				"Message":     message,
				"FileContext": fctx,
			})
		}

		// Insert imports.
		m.AddGeneratorTemplateInjection(targetName, "imports", m.importsTpl, map[string]interface{}{
			"FileContext": fctx,
		})
	}
	return m.Artifacts()
}

const (
	skeletonTplText = `// Code generated by protoc-gen-nproto. DO NOT EDIT.
// source: {{ .File.InputPath }}

package {{ PackageName .File }} // import {{ printf "%+q" (ImportPath .File) }}

// @@protoc_insertion_point(imports)

// @@protoc_insertion_point(nprpc)

// @@protoc_insertion_point(npmsg)
`

	importsTplText = `
{{- $fctx := .FileContext -}}
import (
	{{- $fctx.Import "context" "context" -}}
	{{- $fctx.Import "proto" "github.com/golang/protobuf/proto" -}}
	{{- $fctx.Import "nproto" "github.com/huangjunwen/nproto/nproto" -}}
	{{ range $pkg, $path := .FileContext.Pkg2Path -}}
		{{ $pkg }} {{ printf "%+q" $path }}
	{{ end }}
)

// Avoid import and not used errors.
var (
	_ = context.Background
	_ = proto.Int
	_ = nproto.NewMetaDataPairs
)

`
	nprpcTplText = `
{{- $svc := .Service -}}
{{- $fctx := .FileContext -}}

{{ LeadingComments $svc }}
type {{ Name $svc }} interface {
	{{- range $svc.Methods }}
		{{ LeadingComments . }}
		{{ Name . }}(ctx context.Context, input *{{ $fctx.PackagePrefixed .Input }}) (output *{{ $fctx.PackagePrefixed .Output }}, err error)
	{{ end }}
}

// Serve{{ Name $svc }} serves {{ Name $svc }} service using a RPC server.
func Serve{{ Name $svc }}(server nproto.RPCServer, svcName string, svc {{ Name $svc }}) error {
	return server.RegistSvc(svcName, map[*nproto.RPCMethod]nproto.RPCHandler{
		{{ range $svc.Methods -}}
			method{{ Name $svc }}__{{ Name . }}: func(ctx context.Context, input proto.Message) (proto.Message, error) {
				return svc.{{ Name . }}(ctx, input.(*{{ $fctx.PackagePrefixed .Input }}))
			},
		{{ end -}}
	})
}

// Invoke{{ Name $svc }} invokes {{ Name $svc }} service using a RPC client.
func Invoke{{ Name $svc }}(client nproto.RPCClient, svcName string) {{ Name $svc }} {
	return &client{{ Name $svc }}{
		{{ range $svc.Methods -}}
			handler{{ Name . }}: client.MakeHandler(svcName, method{{ Name $svc }}__{{ Name . }}),
		{{ end }}
	}
}

{{ range $svc.Methods -}}
var method{{ Name $svc }}__{{ Name . }} = &nproto.RPCMethod{
	Name: "{{ Name . }}",
	NewInput: func() proto.Message { return &{{ $fctx.PackagePrefixed .Input }}{} },
	NewOutput: func() proto.Message { return &{{ $fctx.PackagePrefixed .Output }}{} },
}
{{ end }}

type client{{ Name $svc }} struct {
	{{ range $svc.Methods -}}
		handler{{ Name . }} nproto.RPCHandler
	{{ end -}}
}

{{ range $svc.Methods -}}
	// {{ Name . }} implements {{ Name $svc }} interface.
	func (svc *client{{ Name $svc }}) {{ Name . }}(ctx context.Context, input *{{ $fctx.PackagePrefixed .Input }}) (*{{ $fctx.PackagePrefixed .Output }}, error) {
		output, err := svc.handler{{ Name . }}(ctx, input)
		if err != nil {
			return nil, err
		}
		return output.(*{{ $fctx.PackagePrefixed .Output }}), nil
	}
{{ end }}

`
	npmsgTplText = `
{{- $msg := .Message -}}
// Subscribe{{ Name $msg }} subscribes to the specified message channel.
func Subscribe{{ Name $msg }}(subscriber nproto.MsgSubscriber, subject, queue string, handler func(context.Context, *{{ Name $msg }}) error, opts ...interface{}) error {
	return subscriber.Subscribe(
		subject, 
		queue, 
		func(ctx context.Context, msgData []byte) error {
			msg := &{{ Name $msg }}{}
			if err := proto.Unmarshal(msgData, msg); err != nil {
				return err
			}
			return handler(ctx, msg)
		},
		opts...,
	)
}
`
)
