package {{ .File.Package }}

{{- $file := .File }}
{{- $currentFile := $file.Name | getProtoFile }}
{{- $currentPath := $currentFile.GoPkg.Path }}

import (
  "context"
  "sync/atomic"

  "github.com/golang/protobuf/proto"
  nprpc "github.com/huangjunwen/nproto/rpc"
  npmsg "github.com/huangjunwen/nproto/msg"
  {{ range $file.Dependency -}}
    {{ (. | getProtoFile).GoPkg }}
  {{ end -}}
)

{{ range $svc := .File.Service }}

  /* {{""}}{{- leadingComment $svc }}{{""}} */
  type {{ $svc.Name }} interface {
    {{ range $svc.Method -}}
      /* {{""}}{{- leadingComment . | trim -}}{{""}} */
      {{ .Name }}(ctx context.Context, input *{{ (.InputType | getMessageType $file).GoType $currentPath }}) (output *{{ (.OutputType | getMessageType $file).GoType $currentPath }}, err error)
    {{ end }}
  }

  // Serve{{ $svc.Name }} use rpc server to serve {{ $svc.Name }} service.
  func Serve{{ $svc.Name }}(server nprpc.RPCServer, svcName string, svc {{ $svc.Name }}) error {
    return server.RegistSvc(svcName, map[*nprpc.RPCMethod]nprpc.RPCHandler{
      {{ range $svc.Method -}}
        method{{ $svc.Name }}__{{ .Name }}: func(ctx context.Context, input proto.Message) (proto.Message, error) {
          return svc.{{ .Name }}(ctx, input.(*{{ (.InputType | getMessageType $file).GoType $currentPath }}))
        },
      {{ end -}}
    })
  }

  // New{{ $svc.Name }}Client use rpc client to create {{ $svc.Name }} service.
  func New{{ $svc.Name }}Client(client nprpc.RPCClient, svcName string) {{ $svc.Name }} {
    return &client{{ $svc.Name }}{
      svcName: svcName,
      client: client,
    }
  }

  {{ range $svc.Method -}}
    // method{{ $svc.Name }}__{{ .Name }} is descriptor of method {{ $svc.Name }}.{{ .Name }}.
    var method{{ $svc.Name }}__{{ .Name }} = &nprpc.RPCMethod{
      Name: "{{ .Name }}",
      NewInput: func() proto.Message { return &{{ (.InputType | getMessageType $file).GoType $currentPath }}{} },
      NewOutput: func() proto.Message { return &{{ (.OutputType | getMessageType $file).GoType $currentPath }}{} },
    }
  {{ end }}

  // client{{ $svc.Name }} implements {{ $svc.Name }} interface.
  type client{{ $svc.Name }} struct {
    svcName string
    client nprpc.RPCClient
    {{ range $svc.Method -}}
      handler{{ .Name }} atomic.Value // nprpc.RPCHandler
    {{ end -}}
  }

  {{ range $svc.Method }}
    // {{ .Name }} implements {{ $svc.Name }} interface.
    func (svc *client{{ $svc.Name }}) {{ .Name }}(ctx context.Context, input *{{ (.InputType | getMessageType $file).GoType $currentPath }}) (*{{ (.OutputType | getMessageType $file).GoType $currentPath }}, error) {
      v := svc.handler{{ .Name }}.Load()
      if v == nil {
        // NOTE: This branch maybe entered several times but ok.
        v = svc.client.MakeHandler(svc.svcName, method{{ $svc.Name }}__{{ .Name }})
        svc.handler{{ .Name }}.Store(v)
      }
      output, err := v.(nprpc.RPCHandler)(ctx, input)
      if err != nil {
        return nil, err
      }
      return output.(*{{ (.OutputType | getMessageType $file).GoType $currentPath }}), nil
    }
  {{ end }}

{{ end }}

{{ range $msg := .File.MessageType }}
  {{ if regexMatch "<npmsg>" (leadingComment $msg) }}
    // {{ $msg.Name }}MsgHandler creates MsgHandler. The same message will be resend if handler returns error.
    func {{ $msg.Name }}MsgHandler(handler func(context.Context, *{{ $msg.Name }}) error) npmsg.MsgHandler {
      return func(ctx context.Context, msg npmsg.Msg) error {
        m := &{{ $msg.Name }}{}
        if err := proto.Unmarshal(msg.Data(), m); err != nil {
          return err
        }
        return handler(ctx, m)
      }
    }
  {{ end }}
{{ end }}

// Avoid import and not used errors.
var (
  _ = context.Background
  _ = atomic.AddInt32
  _ = proto.Marshal
  _ = nprpc.Passthru
  _ = npmsg.NewMsgConnector
)

